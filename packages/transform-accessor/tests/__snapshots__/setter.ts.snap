// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`@ast-decorators/transform-accessor @setter class-related transformations compiles for computed property 1`] = `
"const $bar = Symbol();

class Foo {
  #_$bar;

  set [$bar](value) {
    const _this = this;

    this.#_$bar = value;
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter class-related transformations compiles for existing setter 1`] = `
"class Foo {
  #bar = '10';

  set bar(value) {
    this.#bar = value;
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter class-related transformations compiles for private property 1`] = `
"class Foo {
  #_bar;

  set #bar(value) {
    const _this = this;

    this.#_bar = value;
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter class-related transformations compiles for property with assignment 1`] = `
"class Foo {
  #_bar = 'baz';

  set bar(value) {
    const _this = this;

    this.#_bar = value;
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter class-related transformations compiles for static property 1`] = `
"class Foo {
  static #_bar;

  static set bar(value) {
    const _this = this;

    this.#_bar = value;
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter class-related transformations compiles without interceptor 1`] = `
"class Foo {
  #_bar;

  set bar(value) {
    const _this = this;

    this.#_bar = value;
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter class-related transformations uses class name instead of this for static property 1`] = `
"class Foo {
  static #_bar;

  static set bar(value) {
    const _this = this;

    Foo.#_bar = value;
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter class-related transformations uses this for static property if class name is absent 1`] = `
"const Foo = class {
  static #_bar;

  static set bar(value) {
    const _this = this;

    this.#_bar = value;
  }

};"
`;

exports[`@ast-decorators/transform-accessor @setter interceptor-related transformations compiles for imported interceptor 1`] = `
"import { set } from './set';

class Foo {
  #_bar;

  set bar(value) {
    const _this = this;

    this.#_bar = set(value, _this);
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter interceptor-related transformations compiles for imported namespace interceptor 1`] = `
"import * as setters from './set';

class Foo {
  #_bar;

  set bar(value) {
    const _this = this;

    this.#_bar = setters.set(value, _this);
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter interceptor-related transformations compiles for the arrow function interceptor 1`] = `
"const _set = value => {
  console.log(value);
  return value;
};

class Foo {
  #_bar;

  set bar(value) {
    const _this = this;

    this.#_bar = _set(value, _this);
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter interceptor-related transformations compiles for the regular function interceptor 1`] = `
"function _set(value) {
  console.log(value);
  return value;
}

class Foo {
  #_bar;

  set bar(value) {
    const _this = this;

    this.#_bar = _set(value, _this);
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter method content compiles for multiple decorators 1`] = `
"import { set1, set2, set3 } from './sets';

class Foo {
  #_bar;

  set bar(value) {
    const _this = this;

    value = set3(value, _this);
    value = set2(value, _this);
    this.#_bar = set1(value, _this);
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter method content creates new this binding if there is no binding in the first statement 1`] = `
"import { set } from './set';

class Foo {
  #bar;
  #baz = '10';

  set bar(value) {
    const _this = this;

    value = set(value, _this);
    value = \`\${value}/\${value}\`;
    const self = this;

    this.#bar = function () {
      return self.#baz + value;
    };
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter method content does not create new this binding if it already exists as the first statement of the method 1`] = `
"import { set } from './set';

class Foo {
  #bar;
  #baz = '10';

  set bar(value) {
    const self = this;
    value = set(value, self);

    this.#bar = function () {
      return self.#baz + value;
    };
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter method content moves the array destructuring of the value param to the method body 1`] = `
"import { set } from './set';

class Foo {
  #bar;

  set bar(_value) {
    const _this = this;

    _value = set(_value, _this);
    const [foo] = _value;
    this.#bar = foo;
  }

}"
`;

exports[`@ast-decorators/transform-accessor @setter method content moves the object destructuring of the value param to the method body 1`] = `
"import { set } from './set';

class Foo {
  #bar;

  set bar(_value) {
    const _this = this;

    _value = set(_value, _this);
    const {
      foo
    } = _value;
    this.#bar = foo;
  }

}"
`;
